#先看个例子
# -*- coding: UTF-8 -*-
def change_number( b ):
    b = 1000

b = 1
change_number(b)
print( b )

# 先看运行结果是1 ，而不是1000？
# 其实这个问题归根结底就是，为什么通过函数change_number没有更改到b的值？
# 这个问题很多编程语言都会讲到，原理解释也是差不多的。
# 这里主要是函数参数的传递中，传递的类型是对象，之前也介绍了python中的基本数据类型等，而这些数据对象可分为
# 更改类型和不更改的类型
# 在python中，字符串，整形，浮点型，tuple是不可更改的对象，而list,dict等是可更改的对象。
# 例如：
# 不可更改的类型： 变量赋值 a = 1,其实就是生成一个整形对象1，然后变量a 指向1，
# 当 a = 1000 其实就是在生成一个整形对象1000，然后改变a的指向，不再指向整形对象1，
# 而是指向1000，最后1会被放弃
#
# 可更改的类型： 变量赋值 a = [1,2,3,4,5,6]，就是生成一个对象list，list里面有6个元素，而变量a 指向list,a[2] = 5
#则是将list a 的第三个元素值更改，这里跟上面的是不同的，并不是将a 重新指向，而是直接修改list 中的元素值。
#
# 这也将影响到函数中参数的传递了：
# 不可更改的类型： 类似c++的值传递，。如整数、字符串、元祖。如fun(a)，传递的只是a的值。没有影响a对象本身。
# 比如在fun(a)的内部修改a的值，只是修改另一个复制的对象，不会影响a本身。
#
# 可更改类型： 类似c++的引用传递。如列表，字典，如fun(a)，则是将a真正的传过去，修改后fun外部的a也会受影响。
#
# 因此，在一开始的例子中， b = 1 ,创建了一个整形对象1，变量指向了这个对象，然后通过函数change_number时，按
# 传值的方式复制了变量b的值，并没有影响到b的本身，具体可看下修改后的实例，通过打印的结果更好的了理解
# -*- coding: UTF-8 -*-
def change_number( b ):
    print('函数中一开始b 的值:{}'.format( b ))
    b = 1000
    print('函数中b赋值后的值: {}'.format( b ))

b = 1
change_number( b )
print('最后输出b的值: {}'.format( b ))


#当然如果参数中是可改变的类型，。那么调用了这个函数后。原来的值也会被更改。具体实例如下：

#-*- coding: UTF-8 -*-
def chang_list( b ):
    print('函数中一开始b的值: {}'.format( b ))
    b.append(1000)
    print('函数中b赋值后的值: {}'.format(b))

b = [1,2,3,4,5]
chang_list( b )
print('最后输出b的值: {}'.format(b))
